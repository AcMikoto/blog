---
title: 设计模式 引言
toc: true
date: 2022-05-20 21:47:26
updated:
tags:
- 设计模式
categories:
---
<!--more-->

# 设计模式

## 什么是设计模式
设计模式四要素：
1. 模式名称：用简单次描述模式的问题，解决方案和效果，设计模式允许较高抽象层次上进行设计。
2. 问题：描述应该何时使用，解释了设计问题和问题存在的前因后果
3. 解决方案：描述设计的组成成分，相互关系，各自职责和协作方式
4. 效果：包括对系统的灵活性，扩充性和可移植性

## 设计模式的编目
- Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，从而无需指定他们具体的类
- Adapter：将一个类的接口转换为客户希望的另一个忌口，使得原本由于接口不兼容而不能一起工作的类可以一起工作
- bridge：将抽象部分与实现部分分离，，是各自可以独立地变化
- builder：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同表示
- chain of Responsibility:为接触请求的发送者和接收者之间耦合，使读个对象都有机会处理该请求
- command：将请求封装为一个对象，从而使可以用不同的请求对客户进行参数化
- composite：将对象组合成树形结构一表示“部分-整体”的层次结构，使得客户对单个对象和复合对象的使用具有一致性
- Decorator：动态的给对象添加一些额外职责，就扩展功能而言，decorator模式比生成子类方式更灵活
- Facade：为子系统中的一组接口提供一致界面，定义一个高层接口是的子系统更容易使用
- factory method: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化
- flyweight： 运用共享技术有效地支持大量细粒度的对象
- interpreter：给定一个语言，定义它的文法的一种表示，并定义一个解释器，使用该解释来解释语言中的句子
- Iterator：提供一种方法顺序访问聚合对象中各个元素，而不暴露其内部表示
- Mediator：用一个中介对象来封装一系列的对象交互，中介者使个对象不需要显式相互引用
- Memento：不破坏封装性前提下，捕获对象的内部状态
- Observer：定义对象间一对多的依赖关系
- Prototype: 用原型实例指定创建对象的种类，并通拷贝这个原型来创建新对象
- Proxy：为其它对象提供一个代理以控制对象的访问
- Singleton： 保证一个类仅有一个实例，并提供一个访问它的全局访问点
- Strategy： 定义一系列算法，并将其逐一封装，使得他们可以相互替换
- template Method: 定义一个操作中算法骨架，从而将一些步骤延迟到子类中，使得子类可以不改变一个算法结构即可重新定义该算法的特定步骤
- vistor： 表示一个作用于某对象结构中的各元素操作，使得可以在不改变各元素的类前提下定义作用于这些元素的新操作。


## 组织编目

根据目的准则，模式是用来完成什么工作
- 创建型：与对象的创建有关
- 结构型：处理类和对象的组合
- 行为型：对类和对象怎样交互和怎样分配职责进行描述

范围准则：
指定模式主要是用于类还是用于对象

类模式处理类和子类之间的关系，类关系是通过继承建立，是静态的
对象模式处理对象间的关系，而对象关系式可以变化，具有动态性， 大部分模式都属于对象模式范畴


## 设计模式如何解决设计问题

### 寻找合适对象