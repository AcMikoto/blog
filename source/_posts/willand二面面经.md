---
title: willand二面面经
toc: true
date: 2022-02-12 20:23:20
updated:
tags:
- 面经
categories:
- 面经
---

# Willand二面复盘
写在前面：面试官人真的超好，尤其是之后的谈心环节很棒，学习到了许多也认识到了许多

概述：大致意思因为了解算法水平，也知道我是才转码的选手，所以更偏重考察C++基础知识这块；

1. 基础
```
const char* a = "abc";
const char* b = "abc";
```

问这里的指针a, b所指向的地址是不是相同的?

没回答对
答案：

首先，这里“abc”是字符串字面量，拥有类型char[],C中曾可以直接赋值给（非 const）char\*,但是C++ 11中不再允许不带转型的这种赋值。

字符串字面量具有静态存储期，注意：cppref中说允许但不要求编译器将相等或者重叠的字符串字面量的存储合并起来（但一般来说是一样的），这就意味着，在以指针比较时，相同的字符串字面量比较时可能相等可能不相等。

实际面试官给的答案是相同，一般来说也没有问题。


2. 说说C++从代码到可执行二进制文件的过程？（基本答对）
从源代码到执行文件，主要有四个过程，预处理、编译、汇编、链接。
- 预处理：处理以#开头的指令
- 编译：将源代码翻译成.s汇编代码
- 汇编：将汇编代码.s翻译成机器指令.o文件
- 链接：汇编程序生成的目标文件并不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。链接的目的就是将这些目标文件连接成一个整体，从而生成可执行程的程序.exe文件

3. C++内存管理（基本答对，没细化答）
C++内存分区：栈、堆、自由存储区、全局/静态存储区，常量区
- 栈：存放函数的局部变量，由编译器自动分配和释放
- 堆：动态申请的内存空间，就是由malloc分配的内存块
- 自由存储区：存放由new分配的内存块
- 全局/静态存储区：存放全局变量和静态变量
- 常量区：存放常量，不允许修改

3. RAII是什么？（基本答了一半?）
称为“资源获取就是初始化”，是C++编程语言中，常见的管理资源，避免内存泄露的方法，保证任何情况下，使用对象时先构造对象，最后析构对象。


4. 类代码
```
class HasPtr {
public:
    HasPtr();
private:
    int i;
    std::string* s;

}
```
提供具体实现使得HasPtr是可复制，可赋值的，以及补全析构函数。

（赋值没写对）

答案：
```
class HasPtr {
public:
    HasPtr();
    HasPtr(const HasPtr& rhs): i(rhs.i), s(new auto(*rhs.s)) {}
    HasPtr& operator=(const& HasPtr& rhs) {
        if(this != &rhs) {
            delete s;
            s = new auto(*rhs.s);
            i = rhs.i;
        }
        return *this;
    }
    ~HasPtr() {
        delete s;
    }
private:
    int i;
    std:: string* s;
}
```

5. static可以修饰？（基本答对）
- 局部变量，对于局部变量，static关键字改变了其内存分配位置，从栈变化到了静态储存区，也改变了其生存周期，
- staitc作用于全局变量和函数，改变了其作用域，使得其只能在定义它的文件中使用。
- staic作用于类的成员变量和成员函数，使得类的成员变量和成员函数和类有关，可以通过类名直接调用，静态类成员变量和成员函数都是类的一部分，而不是对象的一部分，所有这些队形的静态数据成员都共享这一块静态存储空间。

6. 静态函数实现在头文件还是cpp文件？（记不大清了这个）

7. C++三大特点？
封装、继承和多态

8. 静态多态和动态多态？（忘记了）
- 静态多态：编译器在编译期间完成的，编译器会根据实参类型推断调用哪个函数（函数重载？）
- 动态多态：利用虚函数实现以及函数重写实现，

    
9. 单例模式
单例模式是指在整个系统的生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。单例模式是为了保证线程安全。

进阶：C++ 11 有一种用staic实现的方式？
饿汉模式？具体实现写不出来


10. vector<int> a，a中元素是存放到什么位置?

由于vector底层是采用malloc分配空间，所以应该是在堆里面。（这里提醒我要多思考）

11. 了解右值引用吗？
右值通常指表达书结束后就不存在的临时对象，c++11引入了右值引用类型&&用于负责匹配右值

12. 平时有用过多线程吗？unique_lock和lock_guard的区别？
有用过thread和mutex以及条件变量的东西，比较少，
unique_lock和lock_guard都能实现自动加锁和解锁的功能，但是unique_lock相对更灵活，但占用空间相对更大且更慢一些。

13. 如何避免死锁？
动态检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配，所谓安全状态是指，即使所有进程突然请求需要的所有资源，也能存在某种对进程的分配顺序，使得每一个进程运行完毕。（貌似我回答了一通如何预防死锁还是解除死锁，就是说破坏那四个死锁产生的条件）

14. 了解ROS吗？
听说过，其实是机器人相关的一个玩意

15. 进程间通信方式？（基本答出来）
管道、命名管道、信号、信号量、共享内存、套接字

16. IO多路复用？（沾边答了一通）
IO多路复用是指单个进程/线程就可以同时处理多个IO请求
实现原理：用户将想要监视的文件描述符添加到select/poll/epoll函数汇总，由内核监视，函数阻塞，一旦有文件描述符就绪或者超时，函数就会返回，然后进程就可以进行相应的读/写操作


17. 日常常用的stl以及说说其底层实现？
vector，stack，queue，set，multiset，priority_queue。unorderd系列等等，底层随便说了说。


18. Coding
有一个数组，挑出来前面N个最大的元素（要排序）

思路：
堆排序，
快速选择+排序
给了两个基于stl实现的，然后让我手写一下快选，太久没写了我说可能会写出点边界问题，遂让我只说思路，描述了一通；

17. 谈感受环节
提了较多的建议，比较受用



<!--more-->
