---
title: 残酷群Redis学习
toc: true
tags:
  - Redis
categories:
  - 数据库
  - Redis
date: 2022-02-10 21:26:26
updated:
---
<!--more-->
# 残酷群Redis学习

## Redis特点
- redis是键值数据库，支持多种数据结构如string，list，dict，set，zset等等
- redis支持持久化，有两种策略可以将内存中的数据保存到硬盘中RDB（内存快照）和AOF（append only file）
- redis数据读写速度非常快，一方面是因为它把数据读取到内存中操作，另外一方面由于它是采用C语言实现的
- redis提供复制功能，支持主从复制，实现多个相同数据的Redis副本，是分布式Redis的基础
- redis使用单线程模型，避免了线程切换和竞态消耗
- redis所有操作都是原子性，支持事务

## Redis应用场景
- 缓存，由于redis速度快，稳定性强，以及数据类型丰富，可以作为热点数据（经常被查询，但是不经常被修改或者删除的数据）的缓存
- 计数器：例如统计点击数等应用，单线程的优势可以避免并发问题，且redis性能强
- 队列，redis把数据添加大队列并且返回其在队列中的位置，可以用作判断用户访问顺序等。
- 位操作，(大数据处理） 在数据量很大的应用场景下，例如统计用户的在线状态，可以利用将所有用户的在线状态压缩成二进制位
- 分布式锁与单线程机制， 使用redis过滤（一定时间内的）重复请求，数据自动过期等。
- 最新列表，使用redis内置的list
- 适用于数据高并发读写，海量数据读写以及对扩展性要求高的数据

## Redis基本数据结构

Redis共有五种基本数据结构，string（字符串），list（列表），hash（字典），set（集合）以及zset（有序集合）

### string
string是redis中最简单的数据结构，redis中所有的key都是字符串类型，但是value可以有不同的数据结构，Redis中的字符串是动态字符串，内部可以修改（类似于c++ ？ 和python的字符串类型区分开）

redis中的string比较灵活，可以存储整数或者是浮点数。若字符串可以被解释为浮点数或者整数，则支持用户对其进行增or减操作，若对不存在的键or空串键进行增减操作，redis将其值当做0处理。若字符串无法被解释为整数或者浮点数，则返回一个错误。

### list
redis中的list其实是一个双向链表，两端插入或者是删除操作都是O(1)，而随机访问元素是O(n)的。其支持的一些操作与一般的双向链表比较类似

### set
redis中的set类似python的set，是一个无序集合，支持集合元素的插入、删除、查询以及集合间操作。例如交集、并集、差集等。具体操作类似

### zset
相比于set，zset增加另一个分值的概念，在将成员添加到集合中的时候额外赋予其一个分值的概念，然后按照分值排序。注意分值允许重复，加入有序集合中的元素不允许重复。支持查找元素分数以及元素排名，根据分值排名查找元素等操作

### hash
redis中和hash存储的同样是键值对，存储了字段到字段值的映射，一个hsah类型键值至多包含2^32 - 1个字段。

**注意**
redis中的数据类型不支持嵌套，如set。hash中的元素只能是字符串，不支持其它数据类型。

## Redis对象类型
Redis是key/value型数据库，其中每个key和value都是用对象表示的。Redis共有五种对象的类型
1. REDIS_STRING 字符串对象
2. REDIS_LIST 列表对象
3. REDIS_HASH 哈希对象
4. REDIS_SET 集合对象
5. REDIS_ZSET 有序集合对象

为提高效率以及程序执行效率，每种对象底层的数据结构不止一种，据了解，底层数据结构共有八种：
1. REDIS_ENCODING_INT long类型的整数
2. REDIS_ENCODING_EMBSTR embstr编码的简单动态字符串
3. REDIS_ENCODING_RAW 简单动态字符串
4. REDIS_ENCODING_HT 字典
5. REDIS_ENCODING_LINKEDLIST 双端链表
6. REDIS_ENCODING_ZIPLIST 压缩列表
7. REDIS_ENCODING_INTSET 整数集合
8. REIDS_ENCODING_SKIPLIST 跳跃表和字典

- 字符串对象
字符串对象的底层编码可以是int、raw或者是embstr，如果字符串对象可以被解释为整数类型，那么底层就用int类型表示，否则若字符串长度的长度小于39字节，就用embstr对象表示，大于39字节用raw对象表示,embstr对象只需要分配一次内存。
- 列表对象
列表对象的编码可以是ziplist或者是linkedlist，当列表元素个数以及每个元素的值都小于设置值时，使用ziplist，否则使用linkedlist。
- 哈希对象
哈希对象内部有两种实现方式，ziplist和hashtable两种，当字典中元素个数以及每个元素的值都小于设定值时，使用压缩列表实现，否则采用hashtable
- 集合对象
集合对象的内部编码有两种：intset（整数集合）和hashtable（哈希表），当集合中的元素都是整数且集合中的元素数量小于设置值时，采用intset实现，否则采用hashtable实现。
- 有序集合对象
多储存一个score分值，内部采用ziplist或者是skiplist实现，同样地，只有当有序集合元素数量以及每个元素的值都小于设置值时，才使用ziplist否则使用skiplist

## Redis持久化机制
Redis数据平时储存在内存中，属于易失性存储器，因此需要一种持久化方式将其存储到磁盘中，Redis共有两种持久化方式：RDB和AOF，其中RDB是存储快照，属于一次性全量备份，而AOF属于是增量式备份。

### 快照（RDB）
Redis使用操作系统的多进程COW（copy on write）机制实现快照持久化。由于持久化过程中，还需要满足Redis的正常使用，因此Rdedis持久化过程中会调用fork函数产生一个子进程，子进程负责持久化的过程，主进程继续负责提供服务。
通过fork函数创建子进程后，父子进程共享数据，父子进程分别负责提供服务和持久化，过程中父进程写脏的数据会逐渐和子进程分离开。
持久化的内存策略：子进程按照内存页进行复制，通过小数据量数据页的复制（通常4KB）的方式，子进程存储原数据页，父进程对复制出来的数据页进行操作，通过这样的策略，确保RDB快照存储的数据是子进程产生瞬间的数据备份。

快照存储方式可以通过自动触发和手动触发两种：
自动触发 是通过redis.config配置文件规则进行自动配置
手动触发 是通过执行命令手动保存，分为两种：
- save：阻塞式触发，未完成前，客户端无法进行命令操作
- bfsave：非阻塞式触发，主进程fork出子进程进行持久化操作

RDB存储的优点：
- 优点：
	1. 数据结构紧凑，适合作为备份和灾难恢复
	2. RDB快照持久化时，主进程fork出子进程进行备份，主进程无需额外的IO操作
	3. RDB恢复大数据时，速度比较快
- 缺点：
	1. 可能存在兼容性问题，老版RDB无法兼容新版
	2. 无法实时持久化，因为RDB备份消耗较大

### AOF
AOF日志存储的是Redis指令序列，只记录对内存进行修改的指令记录。AOF使用追加记录的方式，在Redis运行过程中，AOF记录会一直变长，因此可以对AOF记录进行重写，即fork一个子进程按照AOF存储的序列对数据进行操作，操作完毕后存储一个新的文件。AOF重写分为两个过程，一个子进程重写原始数据内容，另外就是在fork过程中主进程进行修改的指令。

AOF持久化有三种持久化策略：
1. no： 无fsync，由系统保证刷新到磁盘，速度很快，但是不安全（通常也不用）
2. always：每次都fsync，每一次修改内存的Redis指令都会执行一次fsync，速度慢（通常也不用）
3. everysec：每秒进行一次fsync，可能回丢失一秒的修改数据，综合来说，兼顾了安全和效率，通常采用的是everysec策略。

## RDB和AOF区别

对于RDB和AOF持久化，前者是全量备份，后者是增量备份。
RDB持久化是将内存中的数据定时dump到磁盘中，而AOF持久化是将Redis的操作日志以追加的方式写入文件。
RDB持久化在一定的时间间隔中在内存里面的数据快照写入磁盘，主进程fork一个子进程，以小数据页的形式复制内存中的数据到磁盘中，快照版本为子进程创建时的版本。
AOF持久化面向的是Redis修改命令，通过记录Redis修改数据库的命令，配合原有的数据库，，则可以通过依次操作恢复指定版本。记录到一定长度的操作指令后，可以进行AOF重写。

两者的优势or缺点？
RBD持久化复制出一个完整的备份，适合用于恢复备份。由于RDB是全量备份，资源消耗比较多。
AOF持久化每次记录修改值，并且提供多种同步策略，可以很好地综合效率与安全性，当数据集比较大时，AOF恢复速度不如RDB。

个人看法：
RDB用于定时的做一次全备份，而AOF用于日常的增量备份，两者并不冲突，而是要综合使用的关系。
----

## Redis如何实现事务

简单理解，事务就是将一系列操作（或者命令）打包，事务处理时会按顺序依次执行，要么全部操作执行成功，若其中有一个操作失败，那么整个事务操作将会被回滚，

Redis实现事务主要依靠以下几个命令实现：
- MULTI： 用于标记事务的开始，之后的命令都会存入命令队列，遇到DISCARD或者EXEC操作时，操作才会被取消或者是执行
- EXEC：执行一个事务命令队列中的所有命令，同时将当前状态恢复为正常状态（非事务状态）
- DISCARD：回滚事务中的所有命令，同时将当前状态恢复为正常状态（非事务状态）
- WATCH： MULTI命令执行之前，可以指定待监控的Keys，执行EXEC之前，若被监控的Keys改变，那么EXEC会放弃所有事务中未执行的命令
- UNWATCH：取消某个Keys的监控状态，若执行了EXEC或者DISCARD命令，那么事务中所有被监控的Keys会自动取消监控状态，无需手动执行

事务执行主要经过三个阶段：
事务开始 --> 命令入队 --> 事务执行，对应MULTI命令（事务开始），其它待执行命令（命令入队），EXEC或者DISCARD（事务执行）

## Redis为什么使用单进程

Redis运行在内存中，读写速度很快，而多线程上下文切换的时间消耗相较而言就比较明显，使用单线程可以减少上下文切换的时间消耗。此外，Redis的性能瓶颈在于内存大小以及网络带宽，不在cpu。

单线程的优势：
简单易行，指令串行，不用维护复杂的锁机制，避免资源竞争。同时避免了不必要的上下文切换，减少了CPU消耗

## Redis6.0中的多线程和memcached的多线程区别

### Redis6.0多线程

Redis单线程指获取(socket读)、解析、执行、内容返回(socket写)等都是顺序创新的主线程处理，也即单线程。而其他清理脏数据，释放无用连接，LRU淘汰策略，也是有其他线程处理。

之前提过了Redis这些操作放在同一个主线程：

- 瓶颈不再CPU而在内存和IO
- 多线程会带来线程不安全情况
- 多线程存在线程切换、加锁解锁、死锁性能消耗
- 单线程降低Redis内部实现复杂度
- hash的惰性rehash、lpush等线程不安全命令可以无锁执行。



而Redis6.0引入了多线程。

Redis抽象一套AE事件模型，将IO与时间事件融入，借助多路复用机制(linux中epoll)的回调特性，使得IO读写非阻塞。实现高性能的网络处理能力，加上Redis基于内存处理数据，单线程、但高性能，原因。

IO数据读写仍然阻塞，也是Redis性能瓶颈，特别数据吞吐很大情况下。当socket中有序局，Redis通过系统调用将数据从内核态拷贝到用户态，供Redis解析使用，拷贝的过程是阻塞的，同步IO。数据越大延迟越高，并且都是单线程处理。Redis瓶颈，因此Redis6.0引入"多线程"优化该瓶颈，将主线程的IO读写任务拆分出来给一组独立的线程执行，使得多个socket读写并行化。





Memcache多线程区别：Memcache从IO处理到数据访问多线程实现有区别。**Redis的IO多线程只用于处理网络数据的读写和协议解析，执行命令仍然为单线程。**因为Redis不想因为多线程变复杂，去处理key/lua/事务/LPUSH/LPOP等等的并发问题。



Redis的IO多线程知识在网络数据读写是多线程。

流程：

- 主线程获取socket放入等待队列
- socket分配给IO线程
- 主线程阻塞等待IO线程读取socket完毕
- 主线程以单线程执行命令
- 主线程阻塞，等待IO线程组将数据会写socket完毕
- 解绑定，清空队列。

IO线程要么同时在读socket，要么同时在写。不存在同时读同时写。
IO线程只负责读写socket解析命令，不负责执行命令，由主线程串行执行命令。
IO线程组数目可以配置 默认为1.
上面过程无锁，IO线程处理时，主线程会等待全部IO线程完成。



### Memcached多线程

Memcache线程模型：
Memached服务采用master-worker模式进行，服务端采用socket与客户端同学。主线程、工作线程采用pipe管道同学。主线程采用libevent监听listen、accept读事件，事件响应后将连接信息的数据结构封装，依据算法找对应的工作线程，将连接任务携带连接信息分发，相应的线程利用连接描述符建立与客户端的socket连接，并进行后续的存取数据操作。





### Redis6.0与memcache对比

相同：都用master-worker线程模型

不同点：Memcached执行主逻辑也在worker线程中，模型简单，实现线程隔离，符合线程隔离常规理解。Redis将处理逻辑给master，虽然增加了一些模型复杂度，但是解决了线程并发安全等问题。


## Redis的过期删除策略

通常来说过期删除策略主要分为三种：定时删除、惰性删除以及定期删除

1. 定时删除

定时删除时设置某个key的过期时间，一旦过期则立即执行删除操作，优点是节约内存，缺点是消耗cpu资源

2. 惰性删除

惰性删除是指设置某个key的过期时间后，只有在下次使用它时才去检查其是否过期，若过期则删除，优点是十分节省CPU资源，缺点是是非常占用内存资源，可能会延迟删除许多key，甚至永远无法删除一些之后不会用到的key

3. 定期删除

设置key的过期时间后，每隔一段时间检查是否过期，并统一删除过期key，通过合理设置时间可以较好的综合CPU与内存资源，但是存在致命缺点：某个key删除后但并未到定期删除的时间，下次查询就仍然会返回。

可见，上述过期删除策略都存在各自的优点和缺陷，单一策略的使用难以满足实际需要。因此Redis采用的是惰性删除与定期删除搭配使用的过期删除策略。可以理解为在惰性删除的基础上，每隔一段时间，**随机**从一定数量的数据库随机抽取一定数量的key进行检查，并清理过期键。随机抽取的策略进一步减少了对CPU资源的依赖，同时也较好的平衡了对内存资源的消耗。

## Redis的内存淘汰机制

由于内存空间有限，而数据一直在增加，因此缓存数据总会超过机器内存大小，因此需要设计合适的内存淘汰策略以腾出内存空间。

最新版本的Redis一共有8种内存淘汰机制：

1. noevition:不进行淘汰，内存不够即报错，如果存在爆内存的风险则不能采用此策略
2. allkeys-random：随即删除策略
3. allkeys-lru：使用LRU算法（最近最少使用）进行删除
4. allkeys-lfu：使用LFU算法（最不经常使用）进行删除

allkeys是指在所有数据中筛选，对应的还有在过期数据中筛选（volatile）

5. volatile-random：在过期数据中随机删除
6. volatile-lru：在过期数据中使用LRU删除
7. volatile-lfu：在过期数据中使用LFU删除

特别地针对过期数据还有一个：
8. volatile-ttl：根据过期时间先后删除，优先删除先过期的数据

## Redis部署方式
1. 主从模式
将数据库分为主数据库和从数据库，其中主数据库一般负责写，而从数据库一般负责读，实现读写分离

原理：
- 主数据库正常配置
- 在从数据库中配置跟随的主数据库
- 主数据库收到sync指令后，通过RDB快照当前数据库，结束后发送给从服务器
- 所有的写操作都通过主数据库，然后通过异步方式向从数据库推送增量数据
- 大部分的读操作都通过从数据库
- 主数据库的写入操作和与从数据库的同步是异步进行

优点：可以合理搭配主从数据库的数量将负载有效的分担到不同配置的服务器中。
缺点：由于数据库读写是在不同的数据库中异步实现，因此存在数据不同步的可能性

2. 哨兵模式
对于一主多从的数据库模式，如果主数据库崩溃，则数据库服务中断。有了哨兵模式后，若主数据库崩溃，则可以通过哨兵监控，将从服务器转化为主服务器，哨兵之间也能相互监控。
Redis-sentinel本身是一个独立运行的进程，能够监控多个master-slave集群，发现master宕机后能够进行切换


3. 集群模式
随业务量和数据量的增加，redis性能到达单节点瓶颈，垂直扩容（提升各节点自身的性能，如增加节点的储存空间）受到机器性能限制，而水平扩容（增加节点数量）涉及到对应用的影响以及数据迁移中的丢失风险。
集群模式正是可以解决这些问题，用于实现负载均衡，集群模式主要可以解决分片问题，将整个数据按照规则分布在不同的子节点上，每个节点负责自己部分的数据。

## 如何保证缓存一致性
我们知道Redis常被用于热点数据的缓存以增加查询效率，但是需要保证从Redis中读取到的数据和数据库中存储的数据始终一致

客户端对数据库的操作主要分为两类:读（select）和写操作（DML）。对于读操作而言，若客户端想读取的数据在缓存中，则直接返回（缓存命中），不在redis缓存中则从数据库读入缓存（未命中缓存），因此，可以看到读操作并不会导致缓存与数据库不一致的问题。

而对于写操作，缓存和数据库中的数据都需要改变，而这两个操作不可能保证原子性，必然存在先后顺序，因此就可能导致缓存与数据库数据不一致的问题。

如此存在两个问题：
- 更新缓存or直接淘汰缓存
- 先更新缓存or先更新数据库

对于第一个问题：
   若直接将旧数据从缓存中淘汰，操作十分简单，但下次查询到该数据时会有一次缓存未命中。而更新缓存的话，若数据较为复杂，则存在多次缓存与数据库的交互，整体消耗大，另外多个线程更新缓存也存在先后性的问题，比较麻烦。相比较而言，直接从缓存中淘汰旧数据，操作简单，而且最多带来一次缓存未命中的问题，更加具有优势

对于第二个问题：

考虑先淘汰缓存，然后更新数据库：
	若采用同步更新缓存的策略，在高并发情况下，若某个线程先淘汰了缓存而数据库还未更新，此时另外一个线程到数据库中读取该数据并读入缓存，此时缓存中数据与数据库数据不一致，并且直到该数据下一次被更新均不一致，会带来很长时间的不一致问题。
	解决办法：
	1. 高并发情况下，采用异步更新策略，某个线程进行写操作，先淘汰缓存，此时其它线程读取该数据只从数据库中读而不放入缓存，等到进行写操作的线程成功更新数据库后，通过订阅binlog来异步更新缓存
	2. 若采取同步更新缓存策略，为解决长时间不一致问题，可以采用串行化或者是延时双删策略，写数据进程在完成数据库的更新后，休眠M秒后再次尝试淘汰缓存。延时双删一个是会降低更新操作的吞吐量，另一个是若二次缓存淘汰失败，还会造成长时间的不一致问题，因此还需要引入重试机制，即当二次淘汰失败，报错并继续重试，直至执行成功。

考虑先更新数据库，再淘汰缓存
	更新数据库到淘汰缓存的时间段内，数据库和缓存中的数据不一致，会造成短时间的数据不一致问题，但是此时读取效率高，此外引入重试机制可以防止淘汰缓存失败导致的数据长时间不一致问题，适用于对一致性要求不是很高的业务。

小结：
- 淘汰缓存而不是更新缓存
- 若先淘汰缓存再更新数据库，同步更新缓存策略下存在数据长时间不一致的问题，可以采用串行化或者延时双删等策略，读取效率相对高，数据一致性需要另外保证。异步更新缓存策略下，数据始终一致，但是更新时其它线程都需要到数据库中读取数据，效率低（数据一致性高，适用于对一致性要求高的业务）
- 先更新数据库再淘汰缓存，效率高，数据一段时间不一致，（适用于对一致性要求不太高的业务）

## 什么是缓存雪崩、缓存击穿、缓存穿透？

### 缓存雪崩
概念：某时刻出现大规模的缓存失效（key失效），可能是相同时间过期的key太多或者是Redis宕机，导致大量请求直接到数据库读取，导致数据库压力显著增加，高并发情况下瞬间会导致数据库宕机
解决方案：为防止相同时间过期的key过多，设置过期时间时在原有失效时间上额外增加一个随机值；为防止Redis宕机，可以搭建Redis集群，提高Redis的容灾性；数据库方面，采用分库分表，读写分离策略提高数据库的容灾能力；最后，采用熔断机制，当数据库流量到达一定阈值后，返回“系统拥挤”之类的提示，减轻数据库压力。

### 缓存击穿
概念：雪崩属于大面积的，顾名思义，击穿就是单点的。某个查询热点key失效后，在高并发的情况下，大量针对该热点key的查询直接打到数据库导致数据库压力剧增，叫做缓存击穿。

解决方案：对于热点key，业务允许范围条件下，设置永不过期；或者为减轻数据库压力，使用互斥锁，只有拿到锁才能读取数据，会降低性能

### 缓存穿透
概念：Redis大部分情况下是通过Key查询值，如果请求的key不存在与Redis中，那么请求也会直接打到数据库上，导致数据库压力剧增。
解决方案：可以将无效key存进Redis中，设置为null，但是如果每次key值随机，这种方案则失去作用；使用布隆过滤器，（布隆过滤器：判断某个key不存在则一定不存在于数据库中，判断某个key存在则大概率存在于数据库中，具有一定的误判几率），因此查询之前先用布隆过滤器查询key值是否存在即可。

## 如何用Redis实现一个消息队列？
对于Redis2.0版本之前，常使用List类型或者ZSet类型实现消息队列，其中使用List类型实现的和普通队列实现方式比较类似，易于理解，通过lpush、rpop等操作实现先进先出

利用List实现的消息队列的消息不支持重复消费、没有按照主题订阅的功能、不支持消费消息确认等。

ZSet实现方式和List类似，但由于ZSet多了一个分值属性，因此可以实现更多的功能，比如用来存储时间戳，以此实现延迟消息队列。

Redis2.0之后，Redis新怎了专门的发布和订阅的类型，Publisher（发布者）和Subscriber（订阅者）来实现消息队列。

该模式允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消息队列由对应的消费组消费。

优点：
- 典型广播模式，一个消息可以发送到多个消费者
- 多信道订阅，消费者可以同时订阅多个信道，从而接收多类消息
- 消息即时发送，无需等待消费者读取，消费者会自动接收到信道发布的消息

缺点：
- 消息一旦发布，则后续不能接收，也就是说如果消息发布时若客户端不在线，则消息丢失
- 无法保证每个消费者接收的时间一致
- 若消费者客户端出现消息积压，到一定程度就会被强制断开，导致消息意外丢失，通常发生在消息生产速度远大于消费速度时。

总结： Pub/Sub模式不适合做消息存储，消息积压类的业务，而擅长处理广播，即时通讯，及时反馈的业务。

Redis5.0之后新增了Stream类型，可以利用其xadd和xrange实现消息的存入和读取，并且提供了xack手动确认消息消费的命令，可以用其实现消费者确认的功能。
Stream中有一个消息链表，将所有加入的消息都穿起来，每个消息都有一个唯一的ID和对应的内容。消息是持久化的，Redis重启后内容还在。
每个Stream中都可以挂多个消费组，同一消费组还可以挂多个消费者。

----
**欢迎讨论指正**